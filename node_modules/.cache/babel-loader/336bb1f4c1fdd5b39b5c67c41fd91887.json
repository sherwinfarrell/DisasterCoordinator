{"ast":null,"code":"import L from \"leaflet\";\nL.AnimatedMarker = L.Marker.extend({\n  options: {\n    // meters\n    distance: 200,\n    // ms\n    interval: 1000,\n    // animate on add?\n    autoStart: true,\n    // callback onend\n    onEnd: function () {},\n    clickable: false\n  },\n  initialize: function (latlngs, options) {\n    this.setLine(latlngs);\n    L.Marker.prototype.initialize.call(this, latlngs[0], options);\n  },\n  // Breaks the line up into tiny chunks (see options) ONLY if CSS3 animations\n  // are not supported.\n  _chunk: function (latlngs) {\n    var i,\n        len = latlngs.length,\n        chunkedLatLngs = [];\n\n    for (i = 1; i < len; i++) {\n      var cur = latlngs[i - 1],\n          next = latlngs[i],\n          dist = cur.distanceTo(next),\n          factor = this.options.distance / dist,\n          dLat = factor * (next.lat - cur.lat),\n          dLng = factor * (next.lng - cur.lng);\n\n      if (dist > this.options.distance) {\n        while (dist > this.options.distance) {\n          cur = new L.LatLng(cur.lat + dLat, cur.lng + dLng);\n          dist = cur.distanceTo(next);\n          chunkedLatLngs.push(cur);\n        }\n      } else {\n        chunkedLatLngs.push(cur);\n      }\n    }\n\n    chunkedLatLngs.push(latlngs[len - 1]);\n    return chunkedLatLngs;\n  },\n  onAdd: function (map) {\n    L.Marker.prototype.onAdd.call(this, map); // Start animating when added to the map\n\n    if (this.options.autoStart) {\n      this.start();\n    }\n  },\n  animate: function () {\n    var self = this,\n        len = this._latlngs.length,\n        speed = this.options.interval; // Normalize the transition speed from vertex to vertex\n\n    if (this._i < len && this._i > 0) {\n      speed = this._latlngs[this._i - 1].distanceTo(this._latlngs[this._i]) / this.options.distance * this.options.interval;\n    } // Only if CSS3 transitions are supported\n\n\n    if (L.DomUtil.TRANSITION) {\n      if (this._icon) {\n        this._icon.style[L.DomUtil.TRANSITION] = 'all ' + speed + 'ms linear';\n      }\n\n      if (this._shadow) {\n        this._shadow.style[L.DomUtil.TRANSITION] = 'all ' + speed + 'ms linear';\n      }\n    } // Move to the next vertex\n\n\n    this.setLatLng(this._latlngs[this._i]);\n    this._i++; // Queue up the animation to the next next vertex\n\n    this._tid = setTimeout(function () {\n      if (self._i === len) {\n        self.options.onEnd.apply(self, Array.prototype.slice.call(arguments));\n      } else {\n        self.animate();\n      }\n    }, speed);\n  },\n  // Start the animation\n  start: function () {\n    this.animate();\n  },\n  // Stop the animation in place\n  stop: function () {\n    if (this._tid) {\n      clearTimeout(this._tid);\n    }\n  },\n  setLine: function (latlngs) {\n    if (L.DomUtil.TRANSITION) {\n      // No need to to check up the line if we can animate using CSS3\n      this._latlngs = latlngs;\n    } else {\n      // Chunk up the lines into options.distance bits\n      this._latlngs = this._chunk(latlngs);\n      this.options.distance = 10;\n      this.options.interval = 30;\n    }\n\n    this._i = 0;\n  }\n});\n\nL.animatedMarker = function (latlngs, options) {\n  return new L.AnimatedMarker(latlngs, options);\n};\n\nexport default L.animatedMarker;","map":{"version":3,"sources":["C:/Users/sherwin/projects/ASE Project/LatestClientCoordinator/disastercoordinatorwebview/src/components/Mapping/AnimatedMarker.js"],"names":["L","AnimatedMarker","Marker","extend","options","distance","interval","autoStart","onEnd","clickable","initialize","latlngs","setLine","prototype","call","_chunk","i","len","length","chunkedLatLngs","cur","next","dist","distanceTo","factor","dLat","lat","dLng","lng","LatLng","push","onAdd","map","start","animate","self","_latlngs","speed","_i","DomUtil","TRANSITION","_icon","style","_shadow","setLatLng","_tid","setTimeout","apply","Array","slice","arguments","stop","clearTimeout","animatedMarker"],"mappings":"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","sourcesContent":["import L from \"leaflet\"\r\n\r\nL.AnimatedMarker = L.Marker.extend({\r\n    options: {\r\n      // meters\r\n      distance: 200,\r\n      // ms\r\n      interval: 1000,\r\n      // animate on add?\r\n      autoStart: true,\r\n      // callback onend\r\n      onEnd: function(){},\r\n      clickable: false\r\n    },\r\n  \r\n    initialize: function (latlngs, options) {\r\n      this.setLine(latlngs);\r\n      L.Marker.prototype.initialize.call(this, latlngs[0], options);\r\n    },\r\n  \r\n    // Breaks the line up into tiny chunks (see options) ONLY if CSS3 animations\r\n    // are not supported.\r\n    _chunk: function(latlngs) {\r\n      var i,\r\n          len = latlngs.length,\r\n          chunkedLatLngs = [];\r\n  \r\n      for (i=1;i<len;i++) {\r\n        var cur = latlngs[i-1],\r\n            next = latlngs[i],\r\n            dist = cur.distanceTo(next),\r\n            factor = this.options.distance / dist,\r\n            dLat = factor * (next.lat - cur.lat),\r\n            dLng = factor * (next.lng - cur.lng);\r\n  \r\n        if (dist > this.options.distance) {\r\n          while (dist > this.options.distance) {\r\n            cur = new L.LatLng(cur.lat + dLat, cur.lng + dLng);\r\n            dist = cur.distanceTo(next);\r\n            chunkedLatLngs.push(cur);\r\n          }\r\n        } else {\r\n          chunkedLatLngs.push(cur);\r\n        }\r\n      }\r\n      chunkedLatLngs.push(latlngs[len-1]);\r\n  \r\n      return chunkedLatLngs;\r\n    },\r\n  \r\n    onAdd: function (map) {\r\n      L.Marker.prototype.onAdd.call(this, map);\r\n  \r\n      // Start animating when added to the map\r\n      if (this.options.autoStart) {\r\n        this.start();\r\n      }\r\n    },\r\n  \r\n    animate: function() {\r\n      var self = this,\r\n          len = this._latlngs.length,\r\n          speed = this.options.interval;\r\n  \r\n      // Normalize the transition speed from vertex to vertex\r\n      if (this._i < len && this._i > 0) {\r\n        speed = this._latlngs[this._i-1].distanceTo(this._latlngs[this._i]) / this.options.distance * this.options.interval;\r\n      }\r\n  \r\n      // Only if CSS3 transitions are supported\r\n      if (L.DomUtil.TRANSITION) {\r\n        if (this._icon) { this._icon.style[L.DomUtil.TRANSITION] = ('all ' + speed + 'ms linear'); }\r\n        if (this._shadow) { this._shadow.style[L.DomUtil.TRANSITION] = 'all ' + speed + 'ms linear'; }\r\n      }\r\n  \r\n      // Move to the next vertex\r\n      this.setLatLng(this._latlngs[this._i]);\r\n      this._i++;\r\n  \r\n      // Queue up the animation to the next next vertex\r\n      this._tid = setTimeout(function(){\r\n        if (self._i === len) {\r\n          self.options.onEnd.apply(self, Array.prototype.slice.call(arguments));\r\n        } else {\r\n          self.animate();\r\n        }\r\n      }, speed);\r\n    },\r\n  \r\n    // Start the animation\r\n    start: function() {\r\n      this.animate();\r\n    },\r\n  \r\n    // Stop the animation in place\r\n    stop: function() {\r\n      if (this._tid) {\r\n        clearTimeout(this._tid);\r\n      }\r\n    },\r\n  \r\n    setLine: function(latlngs){\r\n      if (L.DomUtil.TRANSITION) {\r\n        // No need to to check up the line if we can animate using CSS3\r\n        this._latlngs = latlngs;\r\n      } else {\r\n        // Chunk up the lines into options.distance bits\r\n        this._latlngs = this._chunk(latlngs);\r\n        this.options.distance = 10;\r\n        this.options.interval = 30;\r\n      }\r\n      this._i = 0;\r\n    }\r\n  \r\n  });\r\n  \r\n  L.animatedMarker = function (latlngs, options) {\r\n    return new L.AnimatedMarker(latlngs, options);\r\n  };\r\n\r\n\r\n  export default L.animatedMarker;"]},"metadata":{},"sourceType":"module"}