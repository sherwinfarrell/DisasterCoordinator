{"ast":null,"code":"L.AnimatedMarker = L.Marker.extend({\n  options: {\n    // meters\n    distance: 200,\n    // ms\n    interval: 1000,\n    // animate on add?\n    autoStart: true,\n    // callback onend\n    onEnd: function () {},\n    clickable: false\n  },\n  initialize: function (latlngs, options) {\n    this.setLine(latlngs);\n    L.Marker.prototype.initialize.call(this, latlngs[0], options);\n  },\n  // Breaks the line up into tiny chunks (see options) ONLY if CSS3 animations\n  // are not supported.\n  _chunk: function (latlngs) {\n    var i,\n        len = latlngs.length,\n        chunkedLatLngs = [];\n\n    for (i = 1; i < len; i++) {\n      var cur = latlngs[i - 1],\n          next = latlngs[i],\n          dist = cur.distanceTo(next),\n          factor = this.options.distance / dist,\n          dLat = factor * (next.lat - cur.lat),\n          dLng = factor * (next.lng - cur.lng);\n\n      if (dist > this.options.distance) {\n        while (dist > this.options.distance) {\n          cur = new L.LatLng(cur.lat + dLat, cur.lng + dLng);\n          dist = cur.distanceTo(next);\n          chunkedLatLngs.push(cur);\n        }\n      } else {\n        chunkedLatLngs.push(cur);\n      }\n    }\n\n    chunkedLatLngs.push(latlngs[len - 1]);\n    return chunkedLatLngs;\n  },\n  onAdd: function (map) {\n    L.Marker.prototype.onAdd.call(this, map); // Start animating when added to the map\n\n    if (this.options.autoStart) {\n      this.start();\n    }\n  },\n  animate: function () {\n    var self = this,\n        len = this._latlngs.length,\n        speed = this.options.interval; // Normalize the transition speed from vertex to vertex\n\n    if (this._i < len && this.i > 0) {\n      speed = this._latlngs[this._i - 1].distanceTo(this._latlngs[this._i]) / this.options.distance * this.options.interval;\n    } // Only if CSS3 transitions are supported\n\n\n    if (L.DomUtil.TRANSITION) {\n      if (this._icon) {\n        this._icon.style[L.DomUtil.TRANSITION] = 'all ' + speed + 'ms linear';\n      }\n\n      if (this._shadow) {\n        this._shadow.style[L.DomUtil.TRANSITION] = 'all ' + speed + 'ms linear';\n      }\n    } // Move to the next vertex\n\n\n    this.setLatLng(this._latlngs[this._i]);\n    this._i++; // Queue up the animation to the next next vertex\n\n    this._tid = setTimeout(function () {\n      if (self._i === len) {\n        self.options.onEnd.apply(self, Array.prototype.slice.call(arguments));\n      } else {\n        self.animate();\n      }\n    }, speed);\n  },\n  // Start the animation\n  start: function () {\n    this.animate();\n  },\n  // Stop the animation in place\n  stop: function () {\n    if (this._tid) {\n      clearTimeout(this._tid);\n    }\n  },\n  setLine: function (latlngs) {\n    if (L.DomUtil.TRANSITION) {\n      // No need to to check up the line if we can animate using CSS3\n      this._latlngs = latlngs;\n    } else {\n      // Chunk up the lines into options.distance bits\n      this._latlngs = this._chunk(latlngs);\n      this.options.distance = 10;\n      this.options.interval = 30;\n    }\n\n    this._i = 0;\n  }\n});\n\nL.animatedMarker = function (latlngs, options) {\n  return new L.AnimatedMarker(latlngs, options);\n};","map":{"version":3,"sources":["C:/Users/sherwin/projects/ASE Project/LatestClientCoordinator/disastercoordinatorwebview/node_modules/leaflet.animatedmarker/src/AnimatedMarker.js"],"names":["L","AnimatedMarker","Marker","extend","options","distance","interval","autoStart","onEnd","clickable","initialize","latlngs","setLine","prototype","call","_chunk","i","len","length","chunkedLatLngs","cur","next","dist","distanceTo","factor","dLat","lat","dLng","lng","LatLng","push","onAdd","map","start","animate","self","_latlngs","speed","_i","DomUtil","TRANSITION","_icon","style","_shadow","setLatLng","_tid","setTimeout","apply","Array","slice","arguments","stop","clearTimeout","animatedMarker"],"mappings":"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","sourcesContent":["L.AnimatedMarker = L.Marker.extend({\n  options: {\n    // meters\n    distance: 200,\n    // ms\n    interval: 1000,\n    // animate on add?\n    autoStart: true,\n    // callback onend\n    onEnd: function(){},\n    clickable: false\n  },\n\n  initialize: function (latlngs, options) {\n    this.setLine(latlngs);\n    L.Marker.prototype.initialize.call(this, latlngs[0], options);\n  },\n\n  // Breaks the line up into tiny chunks (see options) ONLY if CSS3 animations\n  // are not supported.\n  _chunk: function(latlngs) {\n    var i,\n        len = latlngs.length,\n        chunkedLatLngs = [];\n\n    for (i=1;i<len;i++) {\n      var cur = latlngs[i-1],\n          next = latlngs[i],\n          dist = cur.distanceTo(next),\n          factor = this.options.distance / dist,\n          dLat = factor * (next.lat - cur.lat),\n          dLng = factor * (next.lng - cur.lng);\n\n      if (dist > this.options.distance) {\n        while (dist > this.options.distance) {\n          cur = new L.LatLng(cur.lat + dLat, cur.lng + dLng);\n          dist = cur.distanceTo(next);\n          chunkedLatLngs.push(cur);\n        }\n      } else {\n        chunkedLatLngs.push(cur);\n      }\n    }\n    chunkedLatLngs.push(latlngs[len-1]);\n\n    return chunkedLatLngs;\n  },\n\n  onAdd: function (map) {\n    L.Marker.prototype.onAdd.call(this, map);\n\n    // Start animating when added to the map\n    if (this.options.autoStart) {\n      this.start();\n    }\n  },\n\n  animate: function() {\n    var self = this,\n        len = this._latlngs.length,\n        speed = this.options.interval;\n\n    // Normalize the transition speed from vertex to vertex\n    if (this._i < len && this.i > 0) {\n      speed = this._latlngs[this._i-1].distanceTo(this._latlngs[this._i]) / this.options.distance * this.options.interval;\n    }\n\n    // Only if CSS3 transitions are supported\n    if (L.DomUtil.TRANSITION) {\n      if (this._icon) { this._icon.style[L.DomUtil.TRANSITION] = ('all ' + speed + 'ms linear'); }\n      if (this._shadow) { this._shadow.style[L.DomUtil.TRANSITION] = 'all ' + speed + 'ms linear'; }\n    }\n\n    // Move to the next vertex\n    this.setLatLng(this._latlngs[this._i]);\n    this._i++;\n\n    // Queue up the animation to the next next vertex\n    this._tid = setTimeout(function(){\n      if (self._i === len) {\n        self.options.onEnd.apply(self, Array.prototype.slice.call(arguments));\n      } else {\n        self.animate();\n      }\n    }, speed);\n  },\n\n  // Start the animation\n  start: function() {\n    this.animate();\n  },\n\n  // Stop the animation in place\n  stop: function() {\n    if (this._tid) {\n      clearTimeout(this._tid);\n    }\n  },\n\n  setLine: function(latlngs){\n    if (L.DomUtil.TRANSITION) {\n      // No need to to check up the line if we can animate using CSS3\n      this._latlngs = latlngs;\n    } else {\n      // Chunk up the lines into options.distance bits\n      this._latlngs = this._chunk(latlngs);\n      this.options.distance = 10;\n      this.options.interval = 30;\n    }\n    this._i = 0;\n  }\n\n});\n\nL.animatedMarker = function (latlngs, options) {\n  return new L.AnimatedMarker(latlngs, options);\n};\n"]},"metadata":{},"sourceType":"script"}